{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "-"
    }
   },
   "source": [
    "# Quicksort Demo\n",
    "Author: Mingzhe Wang  \n",
    "Date: May 7, 2022"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## What is quicksort?  \n",
    "<img src=\"quicksort_animation.gif\">\n",
    "\n",
    "Quicksort is a sorting algorithm based on the divide and conquer approach where\n",
    "\n",
    "* An array is divided into subarrays by selecting a pivot element (element selected from the array).\n",
    "\n",
    "* While dividing the array, the pivot element should be positioned in such a way that elements less than pivot are kept on the left side and elements greater than pivot are on the right side of the pivot. The left and right subarrays are also divided using the same approach. This process continues until each subarray contains a single element.\n",
    "\n",
    "* At this point, elements are already sorted. Finally, elements are combined to form a sorted array."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## How quicksort works?\n",
    "Like most divide and conquer algorithm, the quicksort algorithm works by applying the following three stages:  \n",
    "\n",
    "* **Conquer (What is the simplest case that we can directly solve?)**\n",
    "  \n",
    "  An array of size <= 1 is already sorted, since it only has at most one element. \n",
    "  \n",
    "\n",
    "* **Divide (If the current problem is too complex that we cannot solve directly, then divide it into subproblems and try solving them.)**\n",
    "  \n",
    "  For an array of size larger than 1, we select a pivot (a base element), then divide the array into three parts: [all elements smaller than pivot], [pivot], [all elements greater than pivot]. Then we call quicksort() twice for solving the [all elements smaller than pivot] and [all elements greater than pivot].  \n",
    "  \n",
    "  (Note: there will be multiple ways to deal with cases when the element equail the pivot. In this notebook, we will assume the elements equal to the pivot will be put into the left subarray i.e. [all elements smaller than pivot]).  \n",
    "  \n",
    "  \n",
    "* **Merge (If all the subproblems are solved, we should get the right answer for the whole problem by \"merging\" all subproblems.)**\n",
    "  \n",
    "  Unlike mergesort, in quicksort, if we sort all three divisions (i.e. [all elements smaller than pivot], [pivot], [all elements greater than pivot]) of the whole array, then the whole array is automatically sorted. So NOTHING is needed in this stage."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Let's try to implement it."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The first procedure we need is the `quicksort()`. It will sort the array `arr` starting from index `lo` to index `hi` in ascending order.   \n",
    "\n",
    "\n",
    "We can abbreviate this function using the following notation.  \n",
    "```\n",
    "quicksort(arr, lo, hi):\n",
    "Input: \n",
    "  arr - the whole array.\n",
    "  lo - the start index of the array part we want to sort.\n",
    "  hi - the end index of the array part we want to sort.\n",
    "Output:  \n",
    "  null\n",
    "Do:  \n",
    "  sort the given array.\n",
    "```\n",
    "\n",
    "The `quicksort()` procedure will work by following this strategy:  \n",
    "* If it is the conquer case, we sort the array automatically. \n",
    "* Otherwise, divide the current array into three subarrays (i.e. `[all elements smaller than pivot]`, `[pivot]`, `[all elements greater than pivot]`) by calling the `partition()` procedure, which will return the index of the selected pivot. (i.e. `pi`). Then call `quicksort()` again to sort `[all elements smaller than pivot]` and `[all elements greater than pivot]`.\n",
    "\n",
    "Now let's try to implement it in python.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [],
   "source": [
    "def quicksort(arr, lo, hi):\n",
    "  # conquer\n",
    "  if (lo >= hi):\n",
    "    # if array length <= 1\n",
    "    return\n",
    "\n",
    "  # divide & merge\n",
    "  else:\n",
    "    # else array length > 1 \n",
    "    # (note case like lo > hi will not happen based on our recursive calling strategy)\n",
    "    pi = partition(arr, lo, hi)\n",
    "    quicksort(arr, lo, pi - 1)\n",
    "    quicksort(arr, pi + 1, hi)\n",
    "    "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "It's a little amazing, but we really almostly have implemented `quciksort()`. All the task left is the `partition()` procedure.  \n",
    "\n",
    "Recall that the partition procedure will divide the array into three parts: `[all elements smaller than pivot]`, `[pivot]`, `[all elements greater than pivot]` and then return the index of pivot.\n",
    "\n",
    "Before diving into it, note that there are variable versions of quicksort, whose partition may follow different strategies. For this lecture, we follow these strategies:\n",
    "* Always select the rightmost element as the pivot.\n",
    "* If an element equals pivot, then put it into the left subarray (i.e. `[all elements smaller than pivot]`).  \n",
    "\n",
    "Again, we denote the semantic and sytax of the partition() procedure using our notation.\n",
    "```\n",
    "partition():\n",
    "Input: \n",
    "  arr - the whole array.\n",
    "  lo - the start index of the array part we want to divide.\n",
    "  hi - the end index of the array part we want to divide.\n",
    "Output:  \n",
    "  the index indicates where we should put our pivot, such that all the elements in the left are smaller than (or equal to) pivot and all the elements in the right are greated than pivot.\n",
    "Do:  \n",
    "  put the pivot in the right place and do necessary swaps to achieve it.\n",
    "```\n",
    "\n",
    "The `partition()` procedure will work by following this strategy: \n",
    "* Initialize a pointer(index) `i`  to `lo-1`.\n",
    "* Use another pointer `j` to loop through the array. (i.e. `j = low to hi - 1`)  \n",
    "    If we encounter an element $\\leq$ pivot, we increment `i` by 1 and then swap it with the element of index `i` (i.e. `arr[i]`).\n",
    "    Else we encounter an element $>$ pivot, then we simply ignore.\n",
    "* After finishing looping the array by `j` (i.e. `j = hi`), swap pivot with the element of index `i+1`. (i.e. `arr(i+1)`).\n",
    "\n",
    "Now let's try to implement it in python.\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [],
   "source": [
    "def partition(arr, lo, hi):\n",
    "  pivot = arr[hi] # since we always choose the rightmost element as the pivot.\n",
    "  i = lo - 1\n",
    "  \n",
    "  # note in python, range(lo, hi) i.e. interval [lo, hi - 1] or [lo, hi) in math.\n",
    "  for j in range(lo, hi):\n",
    "    if (arr[j] <= pivot):\n",
    "      i = i + 1\n",
    "      arr[i], arr[j] = arr[j], arr[i]\n",
    "    # else, do nothing\n",
    "  arr[i+1], arr[hi] = arr[hi], arr[i+1]\n",
    "\n",
    "  return i+1\n",
    "  "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We are done! \n",
    "Now let's test it."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "original array:  [8, 7, 6, 1, 0, 9, 2]\n",
      "sorted array  [0, 1, 2, 6, 7, 8, 9]\n"
     ]
    }
   ],
   "source": [
    "arr = [8,7,6,1,0,9,2]\n",
    "print(\"original array: \", arr)\n",
    "quicksort(arr, 0, len(arr) - 1)\n",
    "print(\"sorted array \", arr)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The array has been sorted correctly!  \n",
    "\n",
    "However, normally we don't want to specify the start and end indexes for an array, we simply want to the algorithm to sort the whole array. (i.e. we want to use quicksort as `quicksort(arr)` instead of `quicksort(arr, 0, len(arr) - 1)`.)  \n",
    "\n",
    "So we may need to **encapsulate** our function. Below we put all the codes together."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "original array:  [8, 7, 6, 1, 0, 9, 2]\n",
      "sorted array  [0, 1, 2, 6, 7, 8, 9]\n"
     ]
    }
   ],
   "source": [
    "# encapsulate the function so that we sort the entire array by default.\n",
    "def quicksort(arr):\n",
    "  quicksort_rec(arr, 0, len(arr) - 1)\n",
    "\n",
    "def quicksort_rec(arr, lo, hi):\n",
    "  # conquer\n",
    "  if (lo >= hi):\n",
    "    # if array length <= 1\n",
    "    return\n",
    "\n",
    "  # divide & merge\n",
    "  else:\n",
    "    # else array length > 1 \n",
    "    # (note case like lo > hi will not happen based on our recursive calling strategy)\n",
    "    pi = partition(arr, lo, hi)\n",
    "    quicksort_rec(arr, lo, pi - 1)\n",
    "    quicksort_rec(arr, pi + 1, hi)\n",
    "\n",
    "def partition(arr, lo, hi):\n",
    "  pivot = arr[hi] # since we always choose the rightmost element as the pivot.\n",
    "  i = lo - 1\n",
    "  \n",
    "  # note in python, range(lo, hi) i.e. interval [lo, hi - 1] or [lo, hi) in math.\n",
    "  for j in range(lo, hi):\n",
    "    if (arr[j] <= pivot):\n",
    "      i = i + 1\n",
    "      arr[i], arr[j] = arr[j], arr[i]\n",
    "    # else, do nothing\n",
    "  arr[i+1], arr[hi] = arr[hi], arr[i+1]\n",
    "\n",
    "  return i+1\n",
    "\n",
    "# test part\n",
    "arr = [8,7,6,1,0,9,2]\n",
    "print(\"original array: \", arr)\n",
    "quicksort(arr)\n",
    "print(\"sorted array \", arr)\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " Still confused? Let's analysis what `partition()` really does in this small case: `[8,7,6,1,0,9,2]`.\n",
    "\n",
    "Through all this procedure, we maintain a pointer `i` such that the part in index `[0, i]` of this array will hold all the elements $\\leq$ the pivot. To achieve this, we use another pointer `j` to loop through the array -- if we encounter an element $\\leq$ the pivot, then we should put it into the the part in index `[0, i]`. This is achieved by first incrementing `i` by 1 and then swap `arr[i]` with `arr[j]`.\n",
    "\n",
    "Instructor note: \n",
    "* Dry draw this process for the student.\n",
    "* Show how to debug this in spyder."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Exercise\n",
    "1. Instead always selecting the last element as the pivot, implement a `partition()` function which **always selects the first element as the pivot**.\n",
    "\n",
    "2. **Optimiztion by Robert Sedgewick**: Sedgewick's implementation uses a different pointer strategy to compare elements and then detect the right place to put the pivot. Self-learn this strategy by reading the following website:  \n",
    "https://algs4.cs.princeton.edu/23quicksort/"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Appendix\n",
    "### Environment Set up\n",
    "Spyder, Jupyter Notebook, Python, VScode.  \n",
    "Note: All tools can be accessed by simply installing Anaconda and use a common environment.\n",
    "### Reference\n",
    "https://www.programiz.com/dsa/quick-sort  \n",
    "https://visualgo.net/en\n",
    "https://www.tutorialspoint.com/data_structures_algorithms/quick_sort_algorithm.htm\n",
    "https://en.wikipedia.org/wiki/Quicksort\n",
    "https://algs4.cs.princeton.edu/23quicksort/"
   ]
  }
 ],
 "metadata": {
  "celltoolbar": "Slideshow",
  "interpreter": {
   "hash": "01547c21ad8e3418e9cc232ff9a047eae177cfdced01dcd1331cad5b15111bb9"
  },
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
